#为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？
	原因
		执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。
	示例
		fs.readFile('/etc/passwd', function (err, data) {
		  if (err) throw err;
		  console.log(data);
		});
#回调函数噩梦（callback hell）
	由来
		回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。
		    fs.readFile(fileA, function (err, data) {
		      fs.readFile(fileB, function (err, data) {
		        // ...
		      });
		    });
		不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为"回调函数噩梦"（callback hell）。
	解决方案
		方案一：Promise
			Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。
			    var readFile = require('fs-readfile-promise');
			    readFile(fileA)
			    .then(function(data){
			      console.log(data.toString());
			    })
			    .then(function(){
			      return readFile(fileB);
			    })
			    .then(function(data){
			      console.log(data.toString());
			    })
			    .catch(function(err) {
			      console.log(err);
			    });
			Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。
			Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚.
		方案二：Generator函数
			Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。
			    function* gen(x){
			      var y = yield x + 2;
			      return y;
			    }
			上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。
			Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。
			Generator 函数的执行方法如下。
				    var g = gen(1);
				    g.next() // { value: 3, done: false }
				    g.next() // { value: undefined, done: true }
			上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。
			换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。
			虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。
		方案三：Co函数库
			比如，有一个 Generator 函数，用于依次读取两个文件。
			    var gen = function* (){
			      var f1 = yield readFile('/etc/fstab');
			      var f2 = yield readFile('/etc/shells');
			      console.log(f1.toString());
			      console.log(f2.toString());
			    };
			co 函数库可以让你不用编写 Generator 函数的执行器。
			    var co = require('co');
			    co(gen);
			上面代码中，Generator 函数只要传入 co 函数，就会自动执行。
			co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。
			    co(gen).then(function (){
			      console.log('Generator 函数执行完成');
			    })
			co 函数库其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。
			使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。
		方案四：async函数
			异步编程的最高境界，就是根本不用关心它是不是异步。
			一句话，async 函数就是 Generator 函数的语法糖。
			async 函数对 Generator 函数的改进，体现在以下三点。
				1）内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。
			    	var result = asyncReadFile();
				2）更好的语义。 
					async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。
				3）更广的适用性。 
					co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。



